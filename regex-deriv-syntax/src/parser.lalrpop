use std::str::FromStr;
use regex_deriv::{RegEx, ByteSet};
use crate::utils::{literal, range};

grammar;

match {
    r"[^^*+?|()~&\s\[\]-]" => CHAR,
    _
}

pub Expr: RegEx = {
    <r:Clause> <rs:("|" <Clause>)*> => {
        rs.into_iter().fold(r, |acc, regex| acc.or(&regex))
    }
}

Clause: RegEx = {
    <r:Seq> <rs:("&" <Seq>)*> => {
        rs.into_iter().fold(r, |acc, regex| acc.and(&regex))
    }
}

Seq: RegEx = {
    <Term+> => {
        <>.into_iter().reduce(|acc, regex| acc.then(&regex)).unwrap()
    }
}

Term: RegEx = {
    <Factor> "?" => <>.opt(),
    <Factor> "*" => <>.star(),
    <Factor> "+" => <>.plus(),
    "~" <Factor> => <>.not(),
    Factor,
}

Factor: RegEx = {
    "(" <Expr> ")",
    CharClass,
    <CHAR> => literal(<>),
}

CharClass: RegEx = {
    "[" "]" => {
        panic!("character set cannot be empty")
    },
    "[" <r:CCStart> <rs:CCContinue*> "]" => {
        rs.into_iter().fold(r, |acc, regex| acc.or(&regex))
    },
    "[" "^" <CCContinue*> "]" => {
        match <>.into_iter().reduce(|acc, regex| acc.or(&regex)) {
            Some(regex) => todo!(),
            None => todo!(),
        }
    },
}

CCStart: RegEx = {
    <a:CHAR1> "-" <b:CHAR2> => range(a, b),
    <CHAR1> => literal(<>),
    CharClass,
}

CCContinue: RegEx = {
    <a:CHAR2> "-" <b:CHAR2> => range(a, b),
    <CHAR2> => literal(<>),
    CharClass,
}

CHAR1 = {
    CHAR, "*", "+", "?",
}

CHAR2 = {
    CHAR1, "^",
}